\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
\PYGmanni{k}{private} \PYGmanni{n}{T} \PYGmanni{n}{Visit}\PYGmanni{p}{\PYGmanniZlt{}}\PYGmanni{n}{T}\PYGmanni{p}{\PYGmanniZgt{}(}\PYGmanni{n}{T} \PYGmanni{n}{node}\PYGmanni{p}{,} \PYGmanni{n}{Type} \PYGmanni{n}{maxUpcast}\PYGmanni{p}{)}
	\PYGmanni{k}{where} \PYGmanni{n}{T} \PYGmanni{p}{:} \PYGmanni{n}{Node}
\PYGmanni{p}{\PYGmanniZob{}}
	\PYGmanni{k}{if} \PYGmanni{p}{(}\PYGmanni{n}{node} \PYGmanni{p}{==} \PYGmanni{k}{null}\PYGmanni{p}{)}
		\PYGmanni{k}{return} \PYGmanni{k}{null}\PYGmanni{p}{;}

	\PYGmanni{c+c1}{// If a handler exist for this class with convertible return type, invoke.}
	\PYGmanni{k+kt}{var} \PYGmanni{n}{nodeType} \PYGmanni{p}{=} \PYGmanni{n}{node}\PYGmanni{p}{.}\PYGmanni{n}{GetType}\PYGmanni{p}{();}
	\PYGmanni{k}{foreach} \PYGmanni{p}{(}\PYGmanni{k+kt}{var} \PYGmanni{n}{handle} \PYGmanni{k}{in} \PYGmanni{n}{\PYGmanniZus{}handlers}\PYGmanni{p}{)}
	\PYGmanni{p}{\PYGmanniZob{}}
		\PYGmanni{c+c1}{// Test for matching type (or subtype).}
		\PYGmanni{k}{if} \PYGmanni{p}{(!}\PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Type}\PYGmanni{p}{.}\PYGmanni{n}{IsAssignableFrom}\PYGmanni{p}{(}\PYGmanni{n}{nodeType}\PYGmanni{p}{))}
			\PYGmanni{k}{continue}\PYGmanni{p}{;}

		\PYGmanni{c+c1}{// Test for fitness of transformation result.}
		\PYGmanni{k}{if} \PYGmanni{p}{(!}\PYGmanni{n}{maxUpcast}\PYGmanni{p}{.}\PYGmanni{n}{IsAssignableFrom}\PYGmanni{p}{(}\PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{MaxUpcast}\PYGmanni{p}{))}
			\PYGmanni{k}{continue}\PYGmanni{p}{;}

		\PYGmanni{c+c1}{// Test for predicate.}
		\PYGmanni{k}{if} \PYGmanni{p}{(}\PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Predicate} \PYGmanni{p}{!=} \PYGmanni{k}{null}\PYGmanni{p}{)}
		\PYGmanni{p}{\PYGmanniZob{}}
			\PYGmanni{k+kt}{bool} \PYGmanni{n}{result} \PYGmanni{p}{=} \PYGmanni{p}{(}\PYGmanni{k+kt}{bool}\PYGmanni{p}{)} \PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Predicate}\PYGmanni{p}{.}\PYGmanni{n}{DynamicInvoke}\PYGmanni{p}{(}\PYGmanni{n}{node}\PYGmanni{p}{);}
			\PYGmanni{k}{if} \PYGmanni{p}{(!}\PYGmanni{n}{result}\PYGmanni{p}{)}
				\PYGmanni{k}{continue}\PYGmanni{p}{;}
		\PYGmanni{p}{\PYGmanniZcb{}}

		\PYGmanni{c+c1}{// Check if this is an action or function.}
		\PYGmanni{k}{if} \PYGmanni{p}{(}\PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Function} \PYGmanni{p}{!=} \PYGmanni{k}{null}\PYGmanni{p}{)}
		\PYGmanni{p}{\PYGmanniZob{}}
			\PYGmanni{k}{return} \PYGmanni{p}{(}\PYGmanni{n}{T}\PYGmanni{p}{)} \PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Function}\PYGmanni{p}{.}\PYGmanni{n}{DynamicInvoke}\PYGmanni{p}{(}\PYGmanni{n}{node}\PYGmanni{p}{);}
		\PYGmanni{p}{\PYGmanniZcb{}}
		\PYGmanni{k}{else}
		\PYGmanni{p}{\PYGmanniZob{}}
			\PYGmanni{n}{handle}\PYGmanni{p}{.}\PYGmanni{n}{Action}\PYGmanni{p}{.}\PYGmanni{n}{DynamicInvoke}\PYGmanni{p}{(}\PYGmanni{n}{node}\PYGmanni{p}{);}
			\PYGmanni{k}{return} \PYGmanni{n}{node}\PYGmanni{p}{;}
		\PYGmanni{p}{\PYGmanniZcb{}}
	\PYGmanni{p}{\PYGmanniZcb{}}

	\PYGmanni{c+c1}{// If no handlers are found or if all fail, traverse children.}
	\PYGmanni{n}{VisitChildren}\PYGmanni{p}{(}\PYGmanni{n}{node}\PYGmanni{p}{);}

	\PYGmanni{k}{return} \PYGmanni{n}{node}\PYGmanni{p}{;}
\PYGmanni{p}{\PYGmanniZcb{}}
\end{Verbatim}
